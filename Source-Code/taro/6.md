# Taro 源码解读 - TaroMiniPlugin 上篇

本篇文章是 Taro 的源码解读系列的第六篇文章，下面是系列文章链接。

- [Taro 源码解读 - @tarojs/taro 篇](https://github.com/a1029563229/Blogs/tree/master/Source-Code/taro/1.md)
- [Taro 源码解读 - @tarojs/cli 篇](https://github.com/a1029563229/Blogs/tree/master/Source-Code/taro/2.md)
- [Taro 源码解读 - taro build 篇](https://github.com/a1029563229/Blogs/tree/master/Source-Code/taro/3.md)
- [Taro 源码解读 - miniRunner 篇](https://github.com/a1029563229/Blogs/tree/master/Source-Code/taro/4.md)
- [Taro 源码解读 - TaroMiniPlugin 上篇](https://github.com/a1029563229/Blogs/tree/master/Source-Code/taro/5.md)
- [Taro 源码解读 - TaroMiniPlugin 中篇](https://github.com/a1029563229/Blogs/tree/master/Source-Code/taro/6.md)

在上一篇文章 [Taro 源码解读 - TaroMiniPlugin 上篇](https://github.com/a1029563229/Blogs/tree/master/Source-Code/taro/5.md) 中，已经讲解了 `TaroMiniPlugin` 的大致流程，同时介绍了其中的一个 `run` 钩子。接下来我们将继续对 `TaroMiniPlugin` 的其他钩子进行解析。

话不多说，我们开始吧。

## watchRun 钩子

首先，我们来看看紧接在 `run` 钩子以后注册的钩子 —— `watchRun` 吧。

这个钩子会在 `webpack` 监听模式下，一个新的编译被触发之后执行。我们来看看相关的代码实现（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/taro/98.jpg)

从上图可以看出，`watchRun` 和 `run` 钩子所做的事情大同小异，只是多加了对 `isWatch` 和 `loadChunksPlugin` 的判断。除此以外，和 `run` 钩子所做的事情基本一致，都是收集相关依赖添加到 `dependencies` 中。

## make 钩子

看完了 `watchRun` 钩子后，我们来看看 `make` 钩子。`make` 钩子将会在 `compilation` 结束之前执行，代码实现如下。（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/taro/99.jpg)

从上图可以看出，在第 `136` 行时，将会遍历 `dependencies`，将所有的 `dependencies` 通过 `compilation.addEntry` 方法将相关文件添加到需要编译的队列中。

到这一步时，所有的相关文件都会被添加到需要编译的队列中，等待被编译处理。

## compilation 钩子

`compilation` 钩子代表了一次编译过程，在 `compilation` 被创建后执行，也就是在准备开始编译时执行。我们先对这个钩子来个概览解析。（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/taro/100.jpg)

| 代码行数         | 解析                                                                                                             |
| ---------------- | ---------------------------------------------------------------------------------------------------------------- |
| 第 `213、214` 行 | 声明 `SingleEntryDependency` 和 `TaroSingleEntryDependency` 都使用 `normalModuleFactory` 工厂函数来生成 `Module` |
| 第 `220~260` 行  | 在 runLoaders 真正解析资源的前一刻，添加对应的 `Taro loader` 解析相对应的文件                                    |
| 第 `265` 行      | 与原生小程序混写时解析模板与样式                                                                                 |

在这里我们可以看出，`compilation` 所做的主要工作，首先是设置好 `dependencyFactories`，以确保生成正确的 `Module`。最主要的，就是在调用一次编译工作时，在最前端插入对应的 `Loader`。下面我们以 `page` 类型的文件举例（如下图）

![image](http://shadows-mall.oss-cn-shenzhen.aliyuncs.com/images/assets/taro/101.jpg)

从上图可以看出，在解析到 `PAGE` 类型的文件时，将会在 `loaders` 最前端插入 `@tarojs/taro-loader/lib/page`，先行解析文件。

这就是 `TaroMiniPlugin` 中 `compilation` 钩子所做的主要工作，为下一步编译 `chunk` 做准备。

